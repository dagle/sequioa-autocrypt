use crate::acs::{canonicalize, peer::Prefer, store::AutocryptStore};
use acs::{rusqlite::SqliteDriver, store::Wild};
use chrono::Utc;
use sequoia_autocrypt_store as acs;
use sequoia_openpgp::{
    cert::CertParser,
    parse::Parse,
    policy::{Policy, StandardPolicy},
};
use std::env::current_dir;

pub type Result<T> = ::std::result::Result<T, anyhow::Error>;

// We assume that this email is canonicalized
static OUR: &'static str = "art.vandelay@vandelayindustries.com";

// Lets add a peer from our parsed email
fn parsed_email(ac: &AutocryptStore<SqliteDriver, Wild>) -> Result<()> {
    // public key you got from your email parser
    let pubkey = r#"
        -----BEGIN PGP PUBLIC KEY BLOCK-----
        Comment: F705 7B22 D9EF BF63 3243  9EF8 512C 1CED E885 4E2B
        Comment: regina.phalange@friends.com

        xjMEZAtsnxYJKwYBBAHaRw8BAQdAb8vw4h4O5H8CKk5HZAwfz65kBZdzAmh2khwG
        mrAg2dnCwAsEHxYKAH0FgmQLbJ8DCwkHCRBRLBzt6IVOK0cUAAAAAAAeACBzYWx0
        QG5vdGF0aW9ucy5zZXF1b2lhLXBncC5vcmchAU6Eg6CH2V25FrG50lAw0VDAgocl
        S2LLUdO2h6MPdgMVCggCmwECHgEWIQT3BXsi2e+/YzJDnvhRLBzt6IVOKwAARhcA
        /0OZhHoWIDkNlh9B7VFj0ryITsNXj00w/nXTJoUzwsT9AP9FFfguA/ttRttalOxr
        WwedoXekQcskXNQSiPjk6A10Ac0bcmVnaW5hLnBoYWxhbmdlQGZyaWVuZHMuY29t
        wsAOBBMWCgCABYJkC2yfAwsJBwkQUSwc7eiFTitHFAAAAAAAHgAgc2FsdEBub3Rh
        dGlvbnMuc2VxdW9pYS1wZ3Aub3JnLLJBzPN/C/C3btY7clYDZHG7ndwmIIRsH7r/
        YQEtz3kDFQoIApkBApsBAh4BFiEE9wV7Itnvv2MyQ574USwc7eiFTisAANjHAQCn
        SC1g0PxTZHek6lvZOC/IHj4oAIpbgAolScVipFCM8QEAoMQW/XfHRax6eA0Wc/3H
        2kdqApO+3R3kOjg+oRRzpAPOOARkC2yfEgorBgEEAZdVAQUBAQdAQYsPoTtQZgFn
        hEoBp8wr3XO7q53AOfXg3srpMkDlIygDAQgHwsAABBgWCgByBYJkC2yfCRBRLBzt
        6IVOK0cUAAAAAAAeACBzYWx0QG5vdGF0aW9ucy5zZXF1b2lhLXBncC5vcmcVCwjH
        EHzjrSGz4mroUvXlpAvbeBbu1jwKfmtK+qKJZgKbBBYhBPcFeyLZ779jMkOe+FEs
        HO3ohU4rAACNKgD/UPLD+z1JC/xzpmI7WjoBOl6UWHzv58XmWosr72E+tuYBANsl
        lTRbd8m6VJLUleLJqJ4Jq9Jr1Y5U4E2oC0qeX88L
        =vZ8Y
        -----END PGP PUBLIC KEY BLOCK-----"#;

    let cert = CertParser::from_reader(pubkey.as_bytes())?
        .find_map(|cert| cert.ok())
        .ok_or_else(|| anyhow::anyhow!("No cert found"))?;

    // sender, you got from your email parser
    let address = "regina.phalange@friends.com";

    // sender, you got from your email parser
    let date = Utc::now();

    // prefer, you got from your... you guessed it: email parser
    let prefer = Prefer::Mutual;

    // All emails needs to be canonicalize before inserting them into the database
    // or comparisons in the database might fail.
    let canonicalized_email =
        canonicalize(address)?;

    ac.update_peer(OUR, &canonicalized_email, &cert, prefer, date, false)?;
    Ok(())
}

pub fn encrypt(
    ac: &AutocryptStore<SqliteDriver, Wild>,
    policy: &dyn Policy,
    reciever: &str,
) -> Result<()> {
    let msg = "This is my super secret message";

    let mut result = Vec::new();

    let reciever_can =
        canonicalize(reciever)?;

    ac.encrypt(
        policy,
        OUR,
        &[&reciever_can],
        &mut msg.as_bytes(),
        &mut result,
    )?;

    let encrypted = std::str::from_utf8(&result)?;

    // insert the encrypted message into the email builder/mua
    println!("Encrypted message: {}", encrypted);

    // Either you read Prefer from your own settings or use autocrypt to configure it.
    // let account = at.get_account(OUR)?;
    // let headers = ac.header(OUR, policy, account.prefer)?;
    let headers = ac.header(OUR, policy, Prefer::Mutual)?;

    let mut headerstr = vec![];
    headers.serialize(&mut headerstr)?;

    let headerstr = std::str::from_utf8(&headerstr)?;

    // insert autocrytp headers into the email builder/mua
    println!("{}", headerstr);

    Ok(())
}

pub fn decrypt(ac: &AutocryptStore<SqliteDriver, Wild>, policy: &dyn Policy) -> Result<()> {
    // An encrypted message intended for us.
    // Since I can't predict the key generated by update_private_key
    // We just have to imagine a correct message being here
    let msg = "";

    let mut result = Vec::new();

    ac.decrypt(policy, OUR, &mut msg.as_bytes(), &mut result, None)?;

    let decrypted = std::str::from_utf8(&result)?;

    println!("Decrypted message: {}", decrypted);

    Ok(())
}

fn main() -> Result<()> {
    // What keys are acceptable?
    let policy = StandardPolicy::new();

    let mut path = current_dir()?;
    path.push("autocrypt.db");

    let sqlite = SqliteDriver::new(path)?;

    // this function is safe to call multiple times
    // calling this on every startup is fine
    sqlite.setup()?;

    let ac = AutocryptStore::new(sqlite, Some("hunter2"))?;

    // this function is safe to call multiple times, like on every startup
    ac.update_private_key(&policy, OUR)?;

    // we prased an email from regina
    parsed_email(&ac)?;

    // lets create regina an email now that we have her in our db
    encrypt(&ac, &policy, "regina.phalange@friends.com")?;

    // Try to decrypt an email for us, that has been sent
    // using th
    decrypt(&ac, &policy)?;

    Ok(())
}
